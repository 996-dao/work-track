pragma solidity ^0.4.24;
pragma experimental ABIEncoderV2;
contract TimeTrack {
    // Address to represent owner
    address public employer;
    address[] public employeeAddresses;
    Employee[] public employeeEntities;
    uint public employeeIdCount;
    uint public currentBlockTime;
    uint public totalOvertimeCount;
    uint public totalPunchInCount;
    uint public totalPunchOutCount;
    address currentMsgSender;
    Employee public currentEmployee;

    // Datastructure to represent each employee
    struct Employee {
        address employeeAddress;
        bool isActive;
        uint punchDayNum;
        uint overtimeCount;
        bool punchStatus; //true => IN, false => OUT
    }

    struct Card {
        uint punchIn;
        uint punchOut;
    }

    //Stores employee struct for each possible address
    mapping(address => Employee) public employees;
    mapping(address => mapping(uint => Card)) public punchHistory;
    mapping(address => uint) public addrToEmployeeIdMap;

    function TimeTrack() public {
        employer = msg.sender;
        employeeIdCount = 0;
        addEmployee();
    }

    //Make employee inactive in the system
    function removeAuthorization(address addr) public {
        require(msg.sender == employer);
        employees[addr].isActive = false;
    }

    // add an employee given an address and name
    function addEmployee() public returns (bool _success)  {
        currentEmployee = Employee({employeeAddress: msg.sender, isActive: true, punchDayNum: 1, overtimeCount: 1, punchStatus: false});
        addrToEmployeeIdMap[msg.sender] = employeeIdCount;
        employees[msg.sender] = currentEmployee;
        employeeEntities.push(currentEmployee);
        employeeIdCount++;
        employeeAddresses.push(msg.sender);
        return true;
    }

    function displayPunchTime() public view returns (uint) {
     return currentBlockTime;
    }

    function breakViolationAlert() public pure returns (string) {
      return "Break Rules Violated!!!";
    }

    function doPunchIN() public returns (bool _success) {
        // require(
        //     (employer != msg.sender) &&
        //     (employees[msg.sender].isActive) &&
        //     (!employees[msg.sender].card.punchAlert)
        //     );
        currentBlockTime = now;
        currentMsgSender = msg.sender;
        totalPunchInCount++;
        employees[msg.sender].punchDayNum++;
        uint punchDayNum = employees[msg.sender].punchDayNum;
        punchHistory[msg.sender][punchDayNum].punchIn = currentBlockTime;
        employees[msg.sender].punchStatus = true;

        employeeEntities[addrToEmployeeIdMap[currentMsgSender]].punchDayNum++;
        employeeEntities[addrToEmployeeIdMap[currentMsgSender]].punchStatus = true;
        return true;
    }

    function doPunchOUT() public returns (bool _success) {
        // require(
        //     (employer != msg.sender) &&
        //     (employees[msg.sender].isActive) &&
        //     (employees[msg.sender].card.punchAlert)
        //     );
        currentBlockTime = now;
        currentMsgSender = msg.sender;
        totalPunchOutCount++;
        uint punchDayNum = employees[msg.sender].punchDayNum;
        punchHistory[msg.sender][punchDayNum].punchOut = currentBlockTime;
        employees[msg.sender].punchStatus = false;
        caluculateOvertime();

        employeeEntities[addrToEmployeeIdMap[currentMsgSender]].punchStatus = false;
        return true;
    }

    function caluculateOvertime() private {
        uint punchDayNum = employees[msg.sender].punchDayNum;
        uint punchOut = punchHistory[msg.sender][punchDayNum].punchOut;
        uint punchIn = punchHistory[msg.sender][punchDayNum].punchIn;
        require(punchOut > punchIn);
        uint diff = punchOut - punchIn;
        // 为了方便测试，将工作超时时间设置为1min
        if (diff > 60 * 1) {
            employees[msg.sender].overtimeCount++;
            totalOvertimeCount++;
        }
    }

    function getCurrentEmployeeEntityAddress() public view returns(address) {
        return employeeEntities[addrToEmployeeIdMap[msg.sender]].employeeAddress;
    }

    function displayCurrentEmployeeAddress() public view returns(address) {
        return currentEmployee.employeeAddress;
    }

    function getFirstEmployeeEntityAddress() public view returns(address) {
        return employeeEntities[0].employeeAddress;
    }

    function displayTotalOvertimeCount() public view returns(uint) {
        return totalOvertimeCount;
    }

    function displayCurrentMsgSender() public view returns(address) {
        return currentMsgSender;
    }

    function displayTotalPunchInCount() public view returns(uint) {
        return totalPunchInCount;
    }

    function displayTotalPunchOutCount() public view returns(uint) {
        return totalPunchOutCount;
    }

    function getEmployees() public view returns(address[])  {
        return employeeAddresses;
    }

    function displayMyPunchStatus() public view returns (bool) {
        return employees[msg.sender].punchStatus;
    }

    function displayMyPunchDayNum() public view returns (uint) {
        return employees[msg.sender].punchDayNum;
    }
    
    function displayMyOvertimeCount() public view returns (uint) {
        return employees[msg.sender].overtimeCount;
    }

    function displayMyAddr() public view returns (address) {
        return employees[msg.sender].employeeAddress;
    }
}

