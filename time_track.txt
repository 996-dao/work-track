pragma solidity ^0.4.24;
pragma experimental ABIEncoderV2;
contract TimeTrack {
    // Address to represent owner
    address public employer;
    address[] public employeeAddresses;
    uint public employeeIdCount;
    uint currentBlockTime;
    uint totalOvertimeCount;
    uint totalPunchInTime;
    uint totalPunchOutTime;

    // Datastructure to represent each employee
    struct Employee {
        address employeeAddress;
        bool isActive;
        uint punchDayNum;
        uint overtimeCount;
        bool punchStatus; //true => IN, false => OUT
    }

    struct Card {
        uint punchIn;
        uint punchOut;
    }

    //Stores employee struct for each possible address
    mapping(address => Employee) public employees;
    mapping(address => mapping(uint => Card)) public punchHistory;

    function TimeTrack() public {
        employer = msg.sender;
        employeeIdCount = 0;
        addEmployee();
    }

    //Make employee inactive in the system
    function removeAuthorization(address addr) public {
        require(msg.sender == employer);
        employees[addr].isActive = false;
    }

    // add an employee given an address and name
    function addEmployee() public returns (bool _success)  {
        employees[msg.sender] = Employee(msg.sender, true, 0, 0, false);
        employeeIdCount++;
        employeeAddresses.push(msg.sender);
        return true;
    }

    function displayPunchTime() public view returns (uint) {
     return currentBlockTime;
    }

    function breakViolationAlert() public pure returns (string) {
      return "Break Rules Violated!!!";
    }

    function doPunchIN() public returns (bool _success) {
        // require(
        //     (employer != msg.sender) &&
        //     (employees[msg.sender].isActive) &&
        //     (!employees[msg.sender].card.punchAlert)
        //     );
        currentBlockTime = now;
        employees[msg.sender].punchDayNum = employees[msg.sender].punchDayNum + 1;
        uint punchDayNum = employees[msg.sender].punchDayNum;
        punchHistory[msg.sender][punchDayNum].punchIn = currentBlockTime;
        employees[msg.sender].punchStatus = true;
        return true;
    }

    function doPunchOUT() public returns (bool _success) {
        // require(
        //     (employer != msg.sender) &&
        //     (employees[msg.sender].isActive) &&
        //     (employees[msg.sender].card.punchAlert)
        //     );
        currentBlockTime = now;
        uint punchDayNum = employees[msg.sender].punchDayNum;
        punchHistory[msg.sender][punchDayNum].punchOut = currentBlockTime;
        employees[msg.sender].punchStatus = false;
        caluculateOvertime();
        return true;
    }

    function caluculateOvertime() private {
        uint punchDayNum = employees[msg.sender].punchDayNum;
        uint punchOut = punchHistory[msg.sender][punchDayNum].punchOut;
        uint punchIn = punchHistory[msg.sender][punchDayNum].punchIn;
        require(punchOut > punchIn);
        uint diff = punchOut - punchIn;
        // 为了方便测试，将工作超时时间设置为1min
        if (diff > 60 * 1) {
            employees[msg.sender].overtimeCount++;
            totalOvertimeCount++;
        }
    }

    function displayTotalOvertimeCount() public view returns(uint) {
        return totalOvertimeCount;
    }

    function getEmployees() public view returns(address[])  {
        return employeeAddresses;
    }

    function displayMyPunchStatus() public view returns (bool) {
        return employees[msg.sender].punchStatus;
    }

    function displayMyPunchDayNum() public view returns (uint) {
        return employees[msg.sender].punchDayNum;
    }
    
    function displayMyOvertimeCount() public view returns (uint) {
        return employees[msg.sender].overtimeCount;
    }

}

